--------------NamasteJavaScript---------
1.What is Javascript?
   JavaScript is a versatile, high-level programming language primarily used for web development.
   It enables dynamic, interactive experiences on websites, making it one of the core technologies 
   of the World Wide Web alongside HTML and CSS. JavaScript can be used on both the client-side (in the browser)
   and the server-side (using environments like Node.js).
2.How JavaScript works?
    Everything in JavaScript happens inside an "Global execution context".

    Execution context has two components
    1.memory component[variable environment] 
      This is the place where all variables and functions are stored as key value pairs. eg-{key: value ||  n:2;} 

    2.code component[Thread of execution]
      This is the place where code is executed one line at a time
    **For Better Understanding refer this website : https://ui.dev/javascript-visualizer
    Note-
        JavaScript is a synchronous single-threaded language 
      -Single threaded means JavaScript can execute one command at a time
      -Synchronous single-threaded that means JavaScript can execute one command at a time in a specific order.
3.How JavaScript execute?
    1. Whenever any JavaScript code execution started an  Global Execution Context is created and pushed into the callStack.
    2. An Execution Context is basically a box which has two components called Memory Component(Variable Environment) and 
    Code Component(Thread Of Execution).
    3. The Execution context is created in two phases
       a. Memory Creation Phase : In this Phase, Memory is allocated to all the variables and functions in a key-value pair
        which are present in the global scope. Special keyword Undefined in case of variables and literally
        the whole function in case of functions.
       b. Code Execution Phase : In this Phase, code is executed line by line.

    4. Whenever there is a function invocation an all new execution context is created and same process is followed again.
    5. If there is any function parameter then it is also allocated memory while creating the execution context of the function.
    6. Whenever return keyword is encountered , it means the task of function is over and it returns back the control of 
    the program back to the place where it was invoked. and with this execution context is deleted from stack.
    7. Call Stack is basically a stack which maintains the order of execution of execution context.
     Whenever a code is executed the Global Execution Context is pushed into the stack first and later on as per the 
     function invocation the execution context is pushed into the stack. When the function code is done executing the
      execution context is popped out and last the Global Execution Context s also deleted.
4.Hoisting in Js?
    => Hoisting is a JavaScript mechanism or behavior where variables and function declarations are moved to 
    the top of their scope before code execution.
    => Hoisting is not just for variable declarations. It also affects function declarations.
    => In the Execution Context it has two phases, Memory phase and Code Phase, In the Memory Phase all variables are intialized with 
       special keyword "Undefined" and Functions are stored as it is.(Note: Arrow Functions are intialized with Undefined)
    => So, Before code Executed in th code Execution phase , all variables and functions are intialized with special keyword "Undefined"
       and functions are stored as it is.
    => So, we can able access the variable and functions before there declarations. is called as Hoisting.
    => Variable are not Hoisted,Function declarations are Hoisted
    => Example:
              console.log(a);  ==> Output: Undefined
              console.log(getName());  ==> Output: Rakesh
              console.log(getName)   ==> Output: function getName(){console.log("Rakesh");}
              var a = 10;  
              function getName(){
                console.log("Rakesh");
              }

5.How functions Works in Js? Variable Environment?
    => At first a global execution context is created, which consists of Memory and code and 
       has 2 phases: Memory allocation phase and code execution phase.
    =>In the first phase, the variables are assigned "undefined" while functions have their own code.(in a key-value pair)
    =>Whenever there is a function declaration in the code, a separate local execution context gets created 
      having its own phases and is pushed into the call stack.
    =>Once the function ends, the EC is removed from the call stack.
    =>When the program ends, even the global EC is pulled out of the call stack.

6.Lexical Scope?
    =>the lexical scope is the local memory along with the reference of its parent.
    =>Lexical scope refers to how the scope of a variable is determined based on its declaration within the source code.
6.What is Scope?
    =>Scope refers to the context or environment in which variables are declared and accessed. It determines where a particular variable
     is valid and accessible within your code.so the variabels accessible within their scope.in js we have multiple scopes.
     1.Global Scope:
         =>Variables declared outside any function become global. They are accessible from anywhere in your JavaScript program.
         =>Example: var carName = "Volvo"; // Global scope
                        function myFunction() {
                           // Code here can also use carName
                          }
    2.Function Scope:Variables declared within a function are local to that function. They are only accessible within the function.
        =>Functions create their own scope.
        =>Example:function myFunction() {
                    let carName = "Volvo"; // Function scope
                         // Code here can use carName
                  }
    3.Block Scope:Variables declared with let and const have block scope.
        =>Block scope is confined to a pair of curly braces { }
        =>Variables declared inside a block (within { }) cannot be accessed from outside the block.
        =>Example:{
                  let x = 2; // Block scope
                }
                // x cannot be used here


6.SHORTEST JS Program ðŸ”¥window & this keyword ?
    => shortest program in js is i.e is empty page becouse in empty page also it except the global execution context is created.
    => window object is created by the JS engines of the respective browsers when global execution context is created.
	=>whenever an execution context is created a "this" variable is also created.
	=>at the global level "this" points to the global object( window object in case of browsers).
	=>anything that is not inside a function is the "global space".
	=>whenever we create any variables or functions in the "global space", they get attached to the global object( window object in case of browsers).
	=>so to access the variables/function defined in the global space , 
	we can use any of the below:
		console.log(window.a);
		console.log(a);
		console.log(this.a)
7.Undefined Vs not defined ?
    =>Undefined is a Special Placeholder which is used to reserve memory for the variables in the memory creation phase. 
       Even before a single line of code is executed JS engine assigns undefined to the variables.
    =>Not Defined means if we try to console or access any variable which is not declared in the code then we get Not Defined error.
    =>JS is a loosely typed language or weakly typed language means it does not attaches its variables to specific
       data types like in C++ and java.
    =>Remember undefined !== not defined.
8.The Scope Chain, ðŸ”¥Scope & Lexical Environment ?
    =>Lexical Environment: The lexical environment is the local memory along with the lexical environment of its parent.
    => Lexical Scope : the lexical scope is the local memory along with the reference of its parent.
    =>1. Scope of a variable is directly dependent on the lexical environment.
    =>2.Whenever an execution context is created, a lexical environment is created. 
        Lexical environment is the local memory along with the lexical environment of its parent.
        Lexical as a term means in hierarchy or in sequence.
    =>3.Having the reference of parent's lexical environment means, the child or the local function can access all the variables and functions defined in the memory space of its lexical parent.
    =>4.The JS engine first searches for a variable in the current local memory space, if its not found here it
        searches for the variable in the lexical environment of its parent, and if its still not found, 
        then it searches that variable in the subsequent lexical environments, and the sequence goes on until the 
        variable is found in some lexical environment or the lexical environment becomes NULL.
    =>5.The mechanism of searching variables in the subsequent lexical environments is known as Scope Chain. If a 
        variable is not found anywhere, then we say that the variable is not present in the scope chain.
9.let,var,const and Temporal dead Zone?
    =>let and const are hoisted but its memory is allocated at other place than window which cannot be accessed before initialisation.
    =>Temporal Dead Zone exists until variable is declared and assigned a value.
    =>window.variable OR this.variable will not give value of variable defined using let or const.
    =>We cannot redeclare the same variable with let/const(even with using var the second time).
    =>const variable declaration and initialisation must be done on the same line.
    => *There are three types of error: [1] referenceError {given where variable does not have memory allocation} [2] typeError {given when we change type that is not supposed to be changed} [3] syntaxError {when proper syntax(way of writing a statement) is not used}.
    =>Use const wherever possible followed by let, Use var as little as possible(only if you have to). It helps avoid error.
    =>Initialising variables at the top is good idea, helps shrinks TDZ to zero.
10.What is Block?
    =>Code inside curly bracket is called block.==>{}
    =>Multiple statements are grouped inside a block so it can be written where JS expects single statements
      like in if, else, loop, function etc.
    =>Block values are stored inside separate memory than global. They are stored in block. (the reason let and const are called block scope)
    =>Exmaple: if(true){
        console.log("This is called Block");
    }
11.Closure?
    =>Function bundled with its lexical environment is known as a closure. Whenever a function is returned, 
        even if its vanished in execution context but still it remembers the reference it was pointing to. 
        Its not just that function alone it returns but the entire closure
                                              or  
    =>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state 
       (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function.
       In JavaScript, closures are created every time a function is created, at function creation time.
    => Example:
              function x(){
                let a=12;
                function y(){
                    console.log(a)
                }
              }  => In the Example inner function have the access to the outer function scope or parent scope. so,it's bundeld with it's parent scope
        2.    
              function b(){
                let x=11;
                return function a(){
                    console.log(x)
                }
              }   
              let z=b();
              z() => Output==> 11 so,if we return a function even it's still Remember where it from so,it can remember it's parent scope and we can access
                                     it in outside by returning it from a function.   
12.First Class Functions?
    1.Function statement:
        =>A normal function that we create using Naming convention. & By this we can do the Hoisting.
             For Ex  -  function xyz(){
                            console.log("Function Statement");
                       }

    2.What is Function Expression ?
        When we assign a function into a variable that is Function Expression. & We can not do Hoisting by this becz it acts like variable.
            For Ex - var a = function(){
                      console.log("Function Expression");
                    }

    3.What is Anonymous Function ?
        A Function without the name is known as Anonymous Function. & It is used in a place where function are treated as value.
            For Ex - function(){
                     }

    4.What is Named Function Expression ?
        A function with a name is known as Named Function Expression.
            For Ex - var a = function xyx(){
                    console.log("Names Function Expression");
                     }
    5.Difference b/w Parameters and Arguments ?
        =>When we creating a function  & put some variabels in this ( ) that is our Parameters.
            For Ex - function ab( param1, param2 ){
                        console.log("")
                      }
        => & When we call this function & pass a variabel in this ( ) that is our Arguments
        For Ex - ab( 4, 5 );

    6.What is First Class Function Or First class citizens?
        =>The Ability of use function as a value,
        =>Can be passed as an Argument,
        =>Can be executed inside a closured function &
        =>Can be taken as return form it.
            For Ex - var b = function(param){
                             return function xyz(){
                                     console.log(" F C F ");
                             }
                     } 

    7.Function are heart of JS. They are called first class citizens or first class functions because
        they have the ability to be stored in the variables, passed as parameters and arguments. They can also be returned in the function.
13.Call back function?
    =>A callback function is a function that is passed as an argument to another function, and is then invoked inside that function.
    =>It is a way of passing a function as an argument to another function.
    => Example:
              => setTimeOut(function(){
                console.log("Hello");
              },2000)
            => setTimeOut function have the call back function as an argument.
14.Event LooooP?
    =>Event Loop is a single-threaded loop used to manage the asynchronous callbacks.
15.Trust Issues with setTimeOut?
    =>1.The setTimeout function stores it in the callback queue which is executed only after 'call stack' is empty, 
        even if setTimeout is set to 0ms. 
    =>2. setTimeout ensures that minimum it will take the time mentioned because it may be paused due to call stack not empty.
16.Higher Order Functions?
    =>A higher order function is a function that either takes a function as an argument or returns a function.
    1. Follow DRY(Don't Repeat Yourself) principle while coding.
    2. Use function to stop writing repeating line of codes.
    3. Function that takes another function as argument(callback function) is known as Higher order functions.
    4. It is this ability that function can be stored, passed and returned,  they are called first class citizens.
    5. If we use Array.property.function-name. This function is accessible to any array in your code--> Pollyfill
17.Map(),Fliter(),reduce()?
    1.map():map method is used when we want transformation of whole array.
            =>map() creates a new array from calling a function for every array element.
            =>map() does not execute the function for empty elements.
            =>map() does not change the original array.
        =>Syntax: arr.map(callback)
        => For Ex -> var arr = [1,2,3,4,5,6,7,8,9,10];
                    let double=arr.map((ele)=>{
                        return ele*2
                    })
        =>Pollyfill for map() method:
            =>If you are using an array method that is not supported in all browsers, you can use a pollyfill.
            =>i.e means creating our own map method
            =>For Ex -> if(!Array.prototype.map)=>{
                Array.prototype.map = function(callback){
                    let arr=this;
                    let result=[];
                    for(let i=0;i<arr.length;i++){
                        result.push(callback(arr[i],i,arr))
                    }
                    return result
                }
            }
    2.Filter():filter is used when we want to filter the array to obtain required values.
               =>The filter() method creates a new array filled with elements that pass a test provided by a function.
               =>The filter() method does not execute the function for empty elements.
               =>The filter() method does not change the original array.
               =>Syntax: arr.filter(callback)
               =>For Ex -> var arr = [1,2,3,4,5,6,7,8,9,10];
                              let filter=arr.filter((ele)=>{
                                           return ele%2==0;
                                        })
                =>Pollyfill for filter() method:
                =>Creating our own filter method.
                => it's only created with same name if that browers doesn't have with that method.
                =>For Ex -> if(!Array.prototype.filter){
                    Array.prototype.filter = function(callback){
                        let arr=this;
                        let result=[];
                        for(let i=0;i<arr.length;i++){
                            if(callback(arr[i],i,arr)){
                                result.push(arr[i])
                            }

                        }
                        return result
                    }
                }
    3.Reduce() : reduce() method is used when we want to reduce the array to a single value.
                =>It returns a single value
                =>it won't modify the original array
                =>Syntax: array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
                =>For Ex -> var arr = [1,2,3,4,5,6,7,8,9,10];
                            let reduce=arr.reduce((prev,next)=>{
                                        return prev+next;
                                },0)
                =>Pollyfill For Reduce():
                =>If you are using an array method that is not supported in all browsers, you can use a pollyfill.
                =>For Ex -> if(!Array.prototype.reduce){
                    Array.prototype.reduce=function(callback,initialValue){
                        let arr=this;
                        let result=initialValue;
                        for(let i=0;i<arr.length;i++){
                            result=callback(result,arr[i],i,arr)
                        }
                        return result
                    }
                    
                }
18.Callback Hell?
    =>Callback Hell is a situation where you have nested callbacks.This way our code expands horizontally instead of vertically.
    =>When a function is passed as an argument to another function, it becomes a callback function. This process continues 
       and there are many callbacks inside another's Callback function. This grows the code horizontally
       instead of vertically. That mechanism is known as callback hell.
    ExampleðŸ¤©:
        function createOrder(cart,callback){
            chackValidCart(cart,(err,validCart)=>{
                if(err){
                    callback('Cart validation failed');
                }
                else{
                    processPayment(validCart,(err,paymentStatus)=>{
                        if(err){
                            callback('Payment failed');
                        }
                        else if(!paymentStatus.success){
                            callback('Payment failed');
                        }
                        else{
                            paymentConfirmation(paymentStatus,(err,confirmation)=>{
                                if(err){
                                    callback('Payment confirmation failed');
                                }
                                else{
                                    callback(121,'Payment successful');
                                }
                        }
                    }
                }
            })
        } 
        //Example
        createOrder(cart,function(err,orderId){
           if(err){
            console.log('Error while creating order');
           }
           else{
            console.log('Order created successfully');
           }
        }
19.Promises?
    =>The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
    => A promise has 3 states: pending | fulfilled | rejected.
    =>As soon as promise is fulfilled/rejected => It updates the empty object which is assigned undefined in pending state.
    =>A promise resolves only once and it is immutable. 
    =>Using .then() we can control when we call the cb(callback) function.  
    =>Before promise we used to depend on callback functions which would result in 1. Callback Hell (Pyramid of doom) | 
        2.Inversion of control
    =>To avoid callback hell (Pyramid of doom) => We use promise chaining. This way our code expands vertically instead of horizontally. 
      Chaining is done using '.then()'
    =>Note:A very common mistake that developers do is not returning a value during chaining of promises.
     Always remember to return a value. This returned value will be used by the next .then()
    =>Syntax: new Promise(function(resolve,reject){})
    =>For Ex -> var promise=new Promise((resolve,reject)=>{
        let val=true;
        if(val){
            resolve("success")
        }
        else{
            reject("failure)
        }
    })
    promise.then((data)=>{
        console.log(data)
    }).catch((err)=>console.log(err))

    âœ…Promise Methods:
        â˜ï¸Promise.all(): Promise.all method allows you to run multiple promises at the same time. It waits for all of these 
                        operations to complete and gives you the results together.if any one of the promise rejected then result should 
                        also be error.
                        =>Syntax: Promise.all(iterable)
                        => Exmaple1: const promise1 = Promise.resolve(3);
                                    const promise2 = 42; // A non-promise value
                                    const promise3 = new Promise((resolve, reject) => {resolve("foo")});
                                    Promise.all([promise3,promise1, promise2,]).then((values) => {
                                                            console.log(values);
                                                            // Output: [3, 42, 'foo']
                                                                }).catch((error) => {
                                                                        console.log(error);
                                                                                    });
                        => In the example all the promises get successful and the result is also successful.if any one of the promise gives
                            error then result should also be error. 

                        =>Example2: const promise1 = Promise.resolve(3);
                        const promise2 = 42; // A non-promise value
                        const promise3 = new Promise((resolve, reject) => {reject("foo")});
                        Promise.all([promise3,promise1, promise2,]).then((values) => {
                            console.log(values);
                            // Output: foo
                        }).catch((err)=>console.log(err))
        âœŒï¸.Promise.allSettled:
                =>Waits for all promises in the iterable to settle (either fulfilled or rejected).
                =>Returns a single promise that resolves to an array of objects describing the outcome of each promise ({status: 'fulfilled', value: ...} for fulfilled promises and 
                  {status: 'rejected', reason: ...} for rejected promises).
                =>Does not reject immediately if any of the promises are rejected.
                =>Syntax: Promise.allSettled(iterable)
                =>ExampleðŸ¤©: const promise1 = Promise.resolve('A');
                           const promise2 = Promise.reject('Error B');
                           const promise3 = Promise.resolve('C');

                           Promise.allSettled([promise1, promise2, promise3]) 
                      .then((results) => {console.log(results)}); Output==> {status: 'fulfilled', value: 'A'}
                                                                            {status: 'rejected', reason: 'Error B'}
                                                                            {status: 'fulfilled', value: 'C'}
        ðŸ‘Œ.Promise.any:Promise.any is a method in JavaScript that takes an iterable of promises and returns a single promise. 
           This returned promise resolves as soon as any of the input promises resolves, with the value of the first resolved promise. 
           If none of the input promises resolve (i.e., all of them reject), then the returned promise rejects with an AggregateError, 
           which is an error that groups together multiple individual errors.
           => it also generate the AggregateError if all the promises are rejected.
           =>Syntax: Promise.any(iterable)
           =>ExampleðŸš€:const promise1 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Error 1'));
                     const promise2 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 2'));
                     const promise3 = new Promise((resolve) => setTimeout(resolve, 300, 'Success 3'));
                    Promise.any([promise1, promise2, promise3]).then((value) => {console.log(value); //Output: "Success 2"})
        ðŸ––.Promise.race:Promise.race is a method in JavaScript that returns a promise that resolves or rejects as soon as one of the 
           promises in the iterable resolves or rejects. This means it "races" all the provided promises and settles with the outcome of 
           the first settled promise (whether fulfilled or rejected).
           =>Syntax: Promise.race(iterable)
           =>ExampleðŸ¤©:const promise1 = new Promise((resolve) => setTimeout(resolve, 500, 'First'));
                       const promise2 = new Promise((resolve) => setTimeout(resolve, 1000, 'Second'));
                       const promise3 = new Promise((resolve) => setTimeout(resolve, 1500, 'Third'));
                       Promise.race([promise1, promise2, promise3]).then((value) => {console.log(value); // "First"})
20.Async and Await?
    =>Async and Await are two keywords that were introduced in ES6. They allow us to write asynchronous code using the
    same syntax that we use to write synchronous code.
    =>async and await are keywords in JavaScript that provide a more readable and manageable way to work with asynchronous code, 
     making it look and behave more like synchronous code. They are syntactic sugar built on top of promises, making it easier to
     write and understand asynchronous operations.
    1.async Keyword:
        The async keyword is used to declare an asynchronous function. This means that the function will always return a promise, 
         and you can use the await keyword inside it to wait for other promises to resolve.
    2.await Keyword
        The await keyword can only be used inside async functions. It makes JavaScript wait until the promise is settled 
        (either resolved or rejected) and returns the result. If the promise is rejected, await throws the rejected value.
    =>Example:
            const p1 = new Promise( (resolve, reject) =>{ 
            setTimeout(() =>{
  	         resolve("Promise Resolved Value!!")}, 10000);
             });
            const p2 = new Promise( (resolve, reject) =>{ 
                       setTimeout(() =>{
  	                      resolve("Promise Resolved Value!!")}, 5000);
                                });
            async function handlePromise(){
	            console.log("Hello World !!")
	            const val = await p1;
	            console.log("Namaste Javascript")
	            console.log(val)
	            const val2 = await p2;
	            console.log("Namaste Javascript 2")
	            console.log(val2) 
            }

            handlePromise();

           =>In the above condition, when p1 will resolve after 10 seconds, and p2 will resolve after 5 seconds
             then we see that after 10 seconds it will resolve both value. 
             As p2's setTimeout value is lesser(5 Seconds) than p1.(10 Seconds)

             As you said when JavaScript fetch or reach the line of handlePromise function the following this will be happen.

             1. In call stack first handlePromise is loaded and it console log the "Hello World !!"
             2. Then it go to the next line, finds that there has been await p1.
            3. When it saw await p1, handlePromise Function remove from call stack.
            4. After the 10 seconds over, then Function go to call stack and start execution from where it is left.
            5. Now the "Namaste Javascript" is print and also the val value i.e. "Promise Resolved Value!!"  
21.What is DOM?
    => DOM is Document Object Model.
    =>When a web page is loaded, the browser creates a Document Object Model of the html document in the form of tree like structure.
      so,Document will be the root of the DOM tree, and all the child tags, text, comments, and attributes will be the children of the root.
    =>With the help of DOM, we can create, update, and delete elements and also access their properties and styles.
22.Es6 Features?
    =>ES6 is a new version of JavaScript that was released in 2015. It is a significant update to the language that includes new features.
    Some of the new features of ES6 are:
    1.Arrow Functions:arrow functions are the shoter syntax functions of JavaScript. and arrow functions are not hoisted becouse arrow functions
                      usess the Anonymous function and that are stored in the variabel 
    2.let and cost:let and const have block scope 
    3.Template strings:Template strings are string literals that can contain placeholders. These placeholders get replaced with actual values.
    4.Destructuring:Destructuring is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects,
     into distinct variables.
    5.rest operator:rest operetor is used to accept the infinte number of parameters as an array in the function.
        Example:allows us to copy the all the parts of a array.
    6.spread operator:
22.Currying?
    =>Currying is a technique of converting a function that takes multiple arguments into a sequence of functions that each take 
     a single argument.
     =>Example: function add(x,y,z){
                return function(y){
                    return function(z){
                        return x+y+z;
                    }
                }
        }
        =>i.e we are converted the function is => function(x,y,z) to function(x)(y)(z)
22.prototype Inheritance?
   =>inheritance in JS => When an object trying to access variables and properties of another object
      prototype is an Object that get attach to function/method/object and this object has some hidden properties
    =>Whenever we create object/ function/ methods/ array/ variable , these all are attached with some hidden properties, which we call prototype
      _proto_ is reference to prototype ( or it points towards prototype ), if we want to access prototype, we do _proto_
    =>prototype object has a prototype of its own, and so on until an object is reached with null as its prototype,  this is called prototype chaining
22.Call,Apply,Bind Methods?
    1.Call():
        =>Call method is used to borrow properties or methods from another object.
        =>Syntax: object.call(thisArg, arg1, arg2,...)
        Example:
              let p1={
                fname:"Rakesh",
                lname:"Reddy"
                printfullname:function(){
                    console.log("I am "+this.fname+" "+this.lname);
                }
                p1.printfullname() //Output=> I am Rakesh Reddy
              }
              let p2={
                fname:"Praveen",
                lname:"Reddy"
              }
              p1.printfullname.call(p2) //Output=> I am Praveen Reddy   
        =>Here we are calling the printfullname function of p1 object and passing p2 object as thisArg.
        => So, in the Exmaple we are borrowing the printfullname function from p1 object and passing p2 object as thisArg.
        => we can also pass the multiple args in the call method.
        Exmaple:
               let p1={
                fname:"Hareesh",
                lname:"Reddy"
                printfullname:function(city,country){
                    console.log("I am "+this.fname+" "+this.lname+"and i am from "+city+" "+country);
                }
               }
               p1.printfullname("Tirupati","India") //Output=> I am Hareesh Reddy and i am from Tirupati India
               let p2={
                fname:"MuniChandra",
                lname:"Reddy"
               }
               p2.printfullname.call(p1,"Tirupati","India") //Output=> I am Hareesh Reddy and i am from Tirupati India
        =>so,the first arg is obj and remaining args are passed as arguments.we can passs multiple as need

    2.Apply():
        =>Apply method is used to borrow properties or methods from another object.
        =>Apply method is also same as call method, but the only difference is that apply method takes the arguments as array list.
                Exmaple:
               let p1={
                fname:"Hareesh",
                lname:"Reddy"
                printfullname:function(city,country){
                    console.log("I am "+this.fname+" "+this.lname+"and i am from "+city+" "+country);
                }
               }
               p1.printfullname("Tirupati","India") //Output=> I am Hareesh Reddy and i am from Tirupati India
               let p2={
                fname:"MuniChandra",
                lname:"Reddy"
               }
               p2.printfullname.apply(p1,["Tirupati","India"]) //Output=> I am Hareesh Reddy and i am from Tirupati India
        =>Both call and apply method functionality's are that are borrowing properties or methods from anthor object the difference 
          call takes the arguments as the series as arguments but apply method takes the arguments as array list.
    3.Bind():
        =>Bind method is used to borrow properties or methods from another object.it'as also same as call.
        =>But main difference between the call and bind is call method return value but intead of bind method will return a new function.
        =>so,we call the function latter stage of time.
            Exmaple:
               let p1={
                fname:"Hareesh",
                lname:"Reddy"
                printfullname:function(city,country){
                    console.log("I am "+this.fname+" "+this.lname+"and i am from "+city+" "+country);
                }
               }
               p1.printfullname("Tirupati","India") //Output=> I am Hareesh Reddy and i am from Tirupati India
               let p2={
                fname:"MuniChandra",
                lname:"Reddy"
               }
               let val=p2.printfullname.bind(p1,["Tirupati","India"])// return's a function
               console.log(val)//Output=> function(){console.log("I am "+this.fname+" "+this.lname+"and i am from "+city+" "+country);}.
               val()//Output=> I am Hareesh Reddy and i am from Tirupati India
22.What is DOM Events?
    =>DOM events are actions that happen when a user interacts with a web page.
    =>JavaScript HTML DOM events are actions or occurrences that happen in the browser and can be detected and responded to by JavaScript. 
      Events can be things like a user clicking a mouse, pressing a key, or loading a web page. Handling events is a key part of
       making web pages interactive.
    =>Some of the Events are:
         =>click
         =>change
         =>mousehover
         =>mouseout
         =>mousedown
         =>mouseup
23.Event Listener?
   =>Event Listener is function that listens to an event and get executed when the event happened.
   =>Syntax: element.addEventListener(event, function);
23.Event Bubbling,Capturing or Trickling?
    =>Event Bubbling:The process of propagating an event from the target element to its parent element. or 
      the process of propagating from nearest element to the farthest element.
    =>Event Capturing:The process of propagating an event from the target element to its child element. or
      the process of propagating from farthest element to the nearest element is called event Capturing.
    =>StopEventPropagation():The stopEventPropagation() method is used to stop the event propagation.->Syntax:event.stopPropagation()
24.Throttling and Debounce?
    Throttling and Debounce is generally used for performance optimization or rate limiting the function call
    1.Debounce: the time diffrenece between each key stroke is greater than the time frame that we set than only it invoc the function.
         ExampleðŸ¤©: check Throttling and Debounce folder
    2.Throttling:The time difference between the two click events is greater than the time frame that we set than only invoc the function.
